
<!DOCTYPE html>

<html lang="en">

  <head>

    <link

    rel="stylesheet"

    href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css"

  />

  <!-- jQuery library -->

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

  <!-- Latest compiled JavaScript -->

  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>

  <!-- Latest compiled d3 version 3 -->

  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

    <style>

        .line {

            fill: none;

            stroke: #000000;

            stroke-width: 5px;

        }

    </style>

</head>

<body>

    <div class="rect">

 

    <script>

        var svg = d3.select("#rect").append("svg").attr("width", 800).attr("height", 800)

 

        var elem = ".rect";

 

        var props = {

  width: 200,

  height: 100,

  class: "timeline-point",

 

  // margins

  marginTop: 100,

  marginRight: 40,

  marginBottom: 100,

  marginLeft: 40,

 

  // data inputs

  data: [

    {

      x: 90,

      y: 0,

      key: "a",

      image: "arsenal.png",

      id: "a"

    },

    {

      x: 80,

      y: 0,

      key: "b",

      image: "astonvilla.png",

      id: "b"

    },

  ],

 

}

 

// component start

        var rect = {};

 

/***

*

* Create the svg canvas on which the chart will be rendered

*

***/

 

    rect.create = function(svg, props) {

 

  // build the chart foundation

    var svg = d3.select(svg).append('svg')

      .attr('width', 300)

      .attr('height', 300);

 

    var g = svg.append('g')

      .attr('class', 'point-container')

      .attr("width", 200)

      .attr("height", 200);

 

   svg.append('rect')

    .attr('x', 50)

    .attr('y', 120)

    .attr('width', 200)

    .attr('height', 100)

    .attr('stroke', 'black')

    .attr('fill', 'white')

    .attr("opacity", 0.2);

 

  // add placeholders for the axes

  this.update(svg, props);

};

 

/***

*

* Update the svg scales and lines given new data

*

***/

 

rect.update = function(svg, props) {

  var self = this;

  var domain = self.getDomain(props);

  var scales = self.scales(elem, props, domain);

 

  self.drawPoints(elem, props, scales);

};

 

/***

*

* Use the range of values in the x,y attributes

* of the incoming data to identify the plot domain

*

***/

 

rect.getDomain = function(props) {

  var domain = {};

  domain.x = props.xDomain || d3.extent(props.data, function(d) { return d.x; });

  domain.y = props.yDomain || d3.extent(props.data, function(d) { return d.y; });

  return domain;

};

 

/***

*

* Compute the chart scales

*

***/

 

rect.scales = function(elem, props, domain) {

 

  var width = 100;

  var height = 150;

 

  var x = d3.scale.linear()

    .range([0, width])

    .domain(domain.x);

 

  var y = d3.scale.linear()

    .range([height, 0])

    .domain(domain.y);

 

  return {x: x, y: y};

};

 

/***

*

* Use the general update pattern to draw the points

*

***/

rect.drawPoints = function(elem, props, scales, prevScales, dispatcher) {

  var g = d3.select(elem).selectAll('.point-container');

  var color = d3.scale.category10();

 

  // add images

  var image = g.selectAll('.image')

    .data(props.data)

 

  image.enter()

    .append("pattern")

    .attr("id", function(d) {return d.id})

    .attr("class", "svg-image")

    .attr("x", "0")

    .attr("y", "0")

    .attr("height", "1")

    .attr("width", "1")

    .append("image")

      .attr("x", "0")

      .attr("y", "0")

      .attr("height", "50px")

      .attr("width", "60px")

      .attr("xlink:href", function(d) {return d.image})

 

  var point = g.selectAll('.point')

    .data(props.data);

 

  // enter

  point.enter()

    .append("circle")

      .attr("class", "point")

      .on('mouseover', function(d) {

        d3.select(elem).selectAll(".point").classed("active", false);

        d3.select(this).classed("active", true);

        if (props.onMouseover) {

          props.onMouseover(d)

        };

      })

      .on('mouseout', function(d) {

        if (props.onMouseout) {

          props.onMouseout(d)

        };

      })

 

  // enter and update

  point.transition()

    .duration(1000)

    .attr("cx", function(d) {

      return scales.x(d.x); 

    })

    .attr("cy", function(d) { 

      return scales.y(d.y); 

    })

    .attr("r", 30)

    .style("stroke", function(d) {

      if (props.pointStroke) {

        return d.color = props.pointStroke;

      } else {

        return d.color = color(d.key);

      }

    })

    .style("fill", function(d) {

      if (d.image) {

        return ("url(#" + d.id + ")");

      }

 

      if (props.pointFill) {

        return d.color = props.pointFill;

      } else {

        return d.color = color(d.key);

      }

    });

 

  // exit

  point.exit()

    .remove();

 

  // update the axes

  var axes = this.axes(props, scales);

  d3.select(elem).selectAll('g.x.axis')

    .transition()

    .duration(1000)

    .call(axes.xAxis);

 

  d3.select(elem).selectAll('g.y.axis')

    .transition()

    .duration(1000)

    .call(axes.yAxis);

};

 

$(document).ready(function() {

  rect.create(elem, props);

})

</script>

</div>

 

</html>
